'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { Play, Pause, Volume2, VolumeX, Maximize, Minimize, SkipBack, SkipForward } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { Timecode } from '@/types/video-critique';
import { formatTimecode } from '@/lib/data/reviews';

interface VideoPlayerProps {
  videoUrl: string;
  thumbnailUrl?: string;
  onTimeUpdate?: (currentTime: number) => void;
  onDurationChange?: (duration: number) => void;
  onAddTimecode?: (timestamp: number) => void;
  timecodes?: Timecode[];
}

export default function VideoPlayer({
  videoUrl,
  thumbnailUrl,
  onTimeUpdate,
  onDurationChange,
  onAddTimecode,
  timecodes = [],
}: VideoPlayerProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const [isPlaying, setIsPlaying] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [videoScale, setVideoScale] = useState(0.6);
  const [isExpanded, setIsExpanded] = useState(false);

  // Handle play/pause
  const togglePlayPause = useCallback(() => {
    if (!videoRef.current) return;

    if (isPlaying) {
      videoRef.current.pause();
    } else {
      videoRef.current.play();
    }
    setIsPlaying(!isPlaying);
  }, [isPlaying]);

  // Handle mute/unmute
  const toggleMute = useCallback(() => {
    if (!videoRef.current) return;

    videoRef.current.muted = !isMuted;
    setIsMuted(!isMuted);
  }, [isMuted]);

  // Handle volume change
  const handleVolumeChange = useCallback((value: number[]) => {
    if (!videoRef.current) return;

    const newVolume = value[0];
    videoRef.current.volume = newVolume;
    setVolume(newVolume);
    if (newVolume === 0) {
      setIsMuted(true);
    } else if (isMuted) {
      setIsMuted(false);
    }
  }, [isMuted]);

  // Handle seek
  const handleSeek = useCallback((value: number[]) => {
    if (!videoRef.current) return;

    const newTime = value[0];
    videoRef.current.currentTime = newTime;
    setCurrentTime(newTime);
  }, []);

  // Skip forward/backward
  const skip = useCallback((seconds: number) => {
    if (!videoRef.current) return;

    const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
    videoRef.current.currentTime = newTime;
    setCurrentTime(newTime);
  }, [currentTime, duration]);

  // Handle playback rate change
  const handlePlaybackRateChange = useCallback(() => {
    if (!videoRef.current) return;

    const rates = [0.25, 0.5, 1, 1.5, 2];
    const currentIndex = rates.indexOf(playbackRate);
    const nextIndex = (currentIndex + 1) % rates.length;
    const newRate = rates[nextIndex];

    videoRef.current.playbackRate = newRate;
    setPlaybackRate(newRate);
  }, [playbackRate]);

  // Handle fullscreen
  const toggleFullscreen = useCallback(() => {
    if (!containerRef.current) return;

    if (!isFullscreen) {
      if (containerRef.current.requestFullscreen) {
        containerRef.current.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
    setIsFullscreen(!isFullscreen);
  }, [isFullscreen]);

  // Handle video scaling
  const handleScaleChange = useCallback((scale: number) => {
    setVideoScale(Math.max(0.5, Math.min(2, scale)));
  }, []);

  // Handle expand/collapse
  const toggleExpanded = useCallback(() => {
    setIsExpanded(!isExpanded);
  }, [isExpanded]);

  // Keyboard controls
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (!videoRef.current) return;

      switch (e.key) {
        case ' ':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          skip(-5);
          break;
        case 'ArrowRight':
          e.preventDefault();
          skip(5);
          break;
        case 'ArrowUp':
          e.preventDefault();
          handleVolumeChange([Math.min(1, volume + 0.1)]);
          break;
        case 'ArrowDown':
          e.preventDefault();
          handleVolumeChange([Math.max(0, volume - 0.1)]);
          break;
        case 'm':
          e.preventDefault();
          toggleMute();
          break;
        case 'f':
          e.preventDefault();
          toggleFullscreen();
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [togglePlayPause, skip, handleVolumeChange, volume, toggleMute, toggleFullscreen]);

  // Video event handlers
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => {
      setCurrentTime(video.currentTime);
      onTimeUpdate?.(video.currentTime);
    };

    const handleDurationChange = () => {
      setDuration(video.duration);
      onDurationChange?.(video.duration);
    };

    const handleEnded = () => {
      setIsPlaying(false);
    };

    video.addEventListener('timeupdate', handleTimeUpdate);
    video.addEventListener('durationchange', handleDurationChange);
    video.addEventListener('ended', handleEnded);

    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate);
      video.removeEventListener('durationchange', handleDurationChange);
      video.removeEventListener('ended', handleEnded);
    };
  }, [onTimeUpdate, onDurationChange]);

  // Get timecode markers for timeline
  const timecodeMarkers = timecodes.map(tc => ({
    position: (tc.timestamp / duration) * 100,
    type: tc.type,
    timestamp: tc.timestamp,
  }));

  return (
    <div
      ref={containerRef}
      className={`relative bg-black rounded-lg overflow-hidden group ${
        isExpanded ? 'fixed inset-4 z-50' : 'w-full max-w-5xl mx-auto'
      }`}
    >
      {/* Scale and Expand Controls */}
      <div className="absolute top-4 right-4 z-10 flex gap-2">
        <div className="bg-black/70 rounded-lg p-2 flex items-center gap-2">
          <span className="text-white text-sm">Scale:</span>
          <input
            type="range"
            min="0.5"
            max="2"
            step="0.1"
            value={videoScale}
            onChange={(e) => handleScaleChange(parseFloat(e.target.value))}
            className="w-20"
          />
          <span className="text-white text-sm">{Math.round(videoScale * 100)}%</span>
        </div>
        <button
          onClick={toggleExpanded}
          className="bg-black/70 hover:bg-black/90 text-white p-2 rounded-lg transition-colors"
          title={isExpanded ? "Collapse" : "Expand"}
        >
          {isExpanded ? <Minimize className="h-4 w-4" /> : <Maximize className="h-4 w-4" />}
        </button>
      </div>

      <video
        ref={videoRef}
        src={videoUrl}
        poster={thumbnailUrl}
        className="w-full h-auto transition-transform duration-200"
        style={{ transform: `scale(${videoScale})` }}
        onClick={togglePlayPause}
      />

      {/* Controls Overlay */}
      <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-4 opacity-0 group-hover:opacity-100 transition-opacity">
        {/* Timeline with timecode markers */}
        <div className="relative mb-4">
          <Slider
            value={[currentTime]}
            max={duration}
            step={0.1}
            onValueChange={handleSeek}
            className="w-full"
          />
          {/* Timecode markers */}
          {timecodeMarkers.map((marker, index) => (
            <div
              key={index}
              className={`absolute top-0 w-2 h-2 rounded-full -mt-1 cursor-pointer ${
                marker.type === 'praise'
                  ? 'bg-green-500'
                  : marker.type === 'correction'
                  ? 'bg-orange-500'
                  : 'bg-blue-500'
              }`}
              style={{ left: `${marker.position}%` }}
              title={formatTimecode(marker.timestamp)}
              onClick={() => handleSeek([marker.timestamp])}
            />
          ))}
        </div>

        {/* Control buttons */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            {/* Play/Pause */}
            <Button
              size="sm"
              variant="ghost"
              onClick={togglePlayPause}
              className="text-white hover:bg-white/20"
            >
              {isPlaying ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
            </Button>

            {/* Skip buttons */}
            <Button
              size="sm"
              variant="ghost"
              onClick={() => skip(-5)}
              className="text-white hover:bg-white/20"
            >
              <SkipBack className="h-4 w-4" />
            </Button>
            <Button
              size="sm"
              variant="ghost"
              onClick={() => skip(5)}
              className="text-white hover:bg-white/20"
            >
              <SkipForward className="h-4 w-4" />
            </Button>

            {/* Volume */}
            <Button
              size="sm"
              variant="ghost"
              onClick={toggleMute}
              className="text-white hover:bg-white/20"
            >
              {isMuted ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
            </Button>
            <div className="w-24">
              <Slider
                value={[isMuted ? 0 : volume]}
                max={1}
                step={0.1}
                onValueChange={handleVolumeChange}
                className="w-full"
              />
            </div>

            {/* Time display */}
            <span className="text-white text-sm ml-2">
              {formatTimecode(currentTime)} / {formatTimecode(duration)}
            </span>
          </div>

          <div className="flex items-center gap-2">
            {/* Playback speed */}
            <Button
              size="sm"
              variant="ghost"
              onClick={handlePlaybackRateChange}
              className="text-white hover:bg-white/20"
            >
              {playbackRate}x
            </Button>

            {/* Fullscreen */}
            <Button
              size="sm"
              variant="ghost"
              onClick={toggleFullscreen}
              className="text-white hover:bg-white/20"
            >
              <Maximize className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
